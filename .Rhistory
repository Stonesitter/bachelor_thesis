mutate(
is_incorrect = response != correct_response,
last_rule_persisted = !is.na(last_correct_rule),
color_condition = if_else(last_rule_persisted, last_correct_rule == "color" & matching_rule != "color" & chosen_color == response_color, FALSE),
shape_condition = if_else(last_rule_persisted, last_correct_rule == "shape" & matching_rule != "shape" & chosen_shape == response_shape, FALSE),
number_condition = if_else(last_rule_persisted, last_correct_rule == "number" & matching_rule != "number" & chosen_number == response_number, FALSE),
perseverative_error = last_rule_persisted & (color_condition | shape_condition | number_condition)
)
# View the updated dataset
print(look)
# Create the 'correct' column
look <- look %>%
mutate(
correct = response == correct_response
)
# Create the 'shifted_correct' column by shifting the 'correct' column up by one
look <- look %>%
mutate(
shifted_correct = lead(correct)
)
View(look)
rm(list = ls())
saved_names <- c("correct", "matching_rule", "correct_response", "response_shape",
"response_number", "response_color", "color1", "color2",
"color3", "color4", "shape1", "shape2", "shape3", "shape4",
"number1", "number2", "number3", "number4", "response",
"total_correct", "jatosStudyResultId", "total_responses",
"previous_rule", "chosen_color", "chosen_shape", "chosen_number",
"perseverative_error", "is_incorrect", "has_previous_rule",
"color_condition", "shape_condition", "number_condition")
# Load the CSV file
path <- "C:/Users/maalt/ONEDRI~1/Dokumente/Uni/Psychologie/8. Semester/Bachelorarbeit/bachelor_thesis/Experimente/Results/Stichtag_09_07"
setwd(path)
data1 <- read.csv("jatos_results_data_0907_converted.csv")
data2 <- read.csv("jatos_results_data_0907_en_converted.csv")
common_columns <- intersect(names(data1), names(data2))
data1 <- data1[, common_columns]
data2 <- data2[, common_columns]
data <- rbind(data1, data2)
logical <- colnames(data) %in% saved_names
look <- data[ ,logical]
# Create the 'correct' column
look <- look %>%
mutate(
correct = response == correct_response
)
# Create the 'shifted_correct' column by shifting the 'correct' column up by one
look <- look %>%
mutate(
shifted_correct = lead(correct)
)
# Update the data with last correct rule tracking
look <- look %>%
mutate(
last_correct_rule_temp = if_else(response == correct_response, matching_rule, NA_character_),
last_correct_rule = coalesce(last_correct_rule_temp, lag(last_correct_rule, default = NA))
) %>%
select(-last_correct_rule_temp)  # Remove the temporary column
# Initialize the last_correct_rule column
look <- look %>%
mutate(last_correct_rule = NA_character_)
# Update the data with last correct rule tracking
look <- look %>%
mutate(
last_correct_rule_temp = if_else(response == correct_response, matching_rule, NA_character_),
last_correct_rule = coalesce(last_correct_rule_temp, lag(last_correct_rule, default = NA))
) %>%
select(-last_correct_rule_temp)  # Remove the temporary column
# Update the data with last correct rule tracking based on shifted_correct
look <- look %>%
mutate(
last_correct_rule_temp = if_else(shifted_correct, lag(matching_rule), NA_character_),
perseverative_rule = coalesce(last_correct_rule_temp, lag(perseverative_rule, default = NA))
) %>%
select(-last_correct_rule_temp)  # Remove the temporary column
# Initialize the last_correct_rule column
look <- look %>%
mutate(perseverative_rule = NA_character_)
# Update the data with last correct rule tracking based on shifted_correct
look <- look %>%
mutate(
last_correct_rule_temp = if_else(shifted_correct, lag(matching_rule), NA_character_),
perseverative_rule = coalesce(last_correct_rule_temp, lag(perseverative_rule, default = NA))
) %>%
select(-last_correct_rule_temp)  # Remove the temporary column
head(look$perseverative_rule, n = 100)
# Update the data with last correct rule tracking based on shifted_correct
look <- look %>%
mutate(
last_correct_rule_temp = if_else(shifted_correct, matching_rule, NA_character_),
perseverative_rule = if_else(!is.na(last_correct_rule_temp), last_correct_rule_temp, lag(perseverative_rule, default = NA))
) %>%
select(-last_correct_rule_temp)  # Remove the temporary column
# Initialize the 'perseverative_rule' column
look <- look %>%
mutate(
perseverative_rule = NA_character_
)
# Update the 'perseverative_rule' column iteratively
look <- look %>%
mutate(
perseverative_rule = if_else(shifted_correct, matching_rule, NA_character_)
) %>%
fill(perseverative_rule, .direction = "down")
# Update the data with last correct rule tracking based on shifted_correct
look <- look %>%
mutate(
perseverative_rule = if_else(shifted_correct, matching_rule, lag(perseverative_rule, default = NA_character_))
) %>%
mutate(
perseverative_rule = if_else(is.na(perseverative_rule), lag(perseverative_rule, default = NA_character_), perseverative_rule)
)
# Initialize the perseverative_rule column and a variable to store the current value
look$perseverative_rule <- NA_character_
current_value <- NA_character_
# Loop through each row to update perseverative_rule
for (i in 1:nrow(look)) {
if (look$shifted_correct[i]) {
current_value <- look$matching_rule[i]
}
look$perseverative_rule[i] <- current_value
}
# Create the 'shifted_correct' column by shifting the 'correct' column up by one
look <- look %>%
mutate(
shifted_correct = lead(correct, default = TRUE)
)
# Initialize the last_correct_rule column
look <- look %>%
mutate(perseverative_rule = NA_character_)
# Initialize the perseverative_rule column and a variable to store the current value
look$perseverative_rule <- NA_character_
current_value <- NA_character_
# Loop through each row to update perseverative_rule
for (i in 1:nrow(look)) {
if (look$shifted_correct[i]) {
current_value <- look$matching_rule[i]
}
look$perseverative_rule[i] <- current_value
}
# Calculate perseverative errors with updated conditions using the shifted_correct
look <- look %>%
mutate(
is_incorrect = !shifted_correct,
last_rule_persisted = !is.na(last_correct_rule),
color_condition = if_else(last_rule_persisted, last_correct_rule == "color" & matching_rule != "color" & chosen_color == response_color, FALSE),
shape_condition = if_else(last_rule_persisted, last_correct_rule == "shape" & matching_rule != "shape" & chosen_shape == response_shape, FALSE),
number_condition = if_else(last_rule_persisted, last_correct_rule == "number" & matching_rule != "number" & chosen_number == response_number, FALSE),
perseverative_error = last_rule_persisted & (color_condition | shape_condition | number_condition)
)
# Determine the attributes of the chosen card based on the response
look <- look %>%
mutate(
chosen_color = case_when(
response == "a" ~ color1,
response == "b" ~ color2,
response == "c" ~ color3,
response == "d" ~ color4,
TRUE ~ NA_character_
),
chosen_shape = case_when(
response == "a" ~ shape1,
response == "b" ~ shape2,
response == "c" ~ shape3,
response == "d" ~ shape4,
TRUE ~ NA_character_
),
chosen_number = case_when(
response == "a" ~ number1,
response == "b" ~ number2,
response == "c" ~ number3,
response == "d" ~ number4,
TRUE ~ NA_integer_
)
)
# Calculate perseverative errors with updated conditions using the shifted_correct
look <- look %>%
mutate(
is_incorrect = !shifted_correct,
last_rule_persisted = !is.na(last_correct_rule),
color_condition = if_else(last_rule_persisted, last_correct_rule == "color" & matching_rule != "color" & chosen_color == response_color, FALSE),
shape_condition = if_else(last_rule_persisted, last_correct_rule == "shape" & matching_rule != "shape" & chosen_shape == response_shape, FALSE),
number_condition = if_else(last_rule_persisted, last_correct_rule == "number" & matching_rule != "number" & chosen_number == response_number, FALSE),
perseverative_error = last_rule_persisted & (color_condition | shape_condition | number_condition)
)
# View the updated dataset
print(look)
# Calculate perseverative errors with updated conditions using the shifted_correct
look <- look %>%
mutate(
is_incorrect = !shifted_correct,
rule_persisted = !is.na(perseverative_rule),
color_condition = if_else(rule_persisted, perseverative_rule == "color" & matching_rule != "color" & chosen_color == response_color, FALSE),
shape_condition = if_else(rule_persisted, perseverative_rule == "shape" & matching_rule != "shape" & chosen_shape == response_shape, FALSE),
number_condition = if_else(rule_persisted, perseverative_rule == "number" & matching_rule != "number" & chosen_number == response_number, FALSE),
perseverative_error = rule_persisted & (color_condition | shape_condition | number_condition)
)
# Calculate perseverative errors with updated conditions using the shifted_correct
look <- look %>%
mutate(
is_incorrect = !shifted_correct,
rule_persisted = !is.na(perseverative_rule),
color_condition = if_else(rule_persisted, perseverative_rule == "color" & matching_rule != "color" & chosen_color == response_color, FALSE),
shape_condition = if_else(rule_persisted, perseverative_rule == "shape" & matching_rule != "shape" & chosen_shape == response_shape, FALSE),
number_condition = if_else(rule_persisted, perseverative_rule == "number" & matching_rule != "number" & chosen_number == response_number, FALSE),
perseverative_error = rule_persisted & (color_condition | shape_condition | number_condition)
)
# View the updated dataset
print(look)
look <- look %>%
mutate(
cum_perseverative_errors = cumsum(perseverative_error)
)
# Select the required columns
selected_data <- look[, c("jatosStudyResultId", "total_correct", "total_responses", "cum_perseverative_error")]
look <- look %>%
mutate(
cum_perseverative_errors = cumsum(perseverative_error)
)
# Add a column to count the cumulative number of perseverative errors
look <- look %>%
mutate(
cum_perseverative_error = cumsum(perseverative_error)
)
# Select the required columns
selected_data <- look[, c("jatosStudyResultId", "total_correct", "total_responses", "cum_perseverative_error")]
# Filter to keep only the rows where total_responses is 64
last_trial_data <- selected_data[selected_data$total_responses == 64, ]
# Sort the data by jatosStudyResultId
sorted_data <- last_trial_data[order(last_trial_data$jatosStudyResultId), ]
rownames(sorted_data) <- NULL
metadata1 <- read.csv("jatos_results_metadata_0907.csv")
metadata2 <- read.csv("jatos_results_metadata_0907_en.csv")
metadata <- rbind(metadata1, metadata2)
colnames(metadata)[colnames(metadata) == "Result.ID"] <- "jatosStudyResultId"
# Merge the two data.frames
exp_result <- merge(sorted_data, metadata[, c("jatosStudyResultId", "Start.time", "Duration")],
by = "jatosStudyResultId", all.x = TRUE)
exp_result$total_responses <- NULL
# head(exp_result, n = 120)
exp_result
nrow(exp_result)
# Add a column to count the cumulative number of perseverative errors for each participant
look <- look %>%
group_by(jatosStudyResultId) %>%  # Use 'jatosStudyResultId' to group by participant
mutate(
cum_perseverative_error = cumsum(perseverative_error)
) %>%
ungroup()
# Select the required columns
selected_data <- look[, c("jatosStudyResultId", "total_correct", "total_responses", "cum_perseverative_error")]
# Filter to keep only the rows where total_responses is 64
last_trial_data <- selected_data[selected_data$total_responses == 64, ]
# Sort the data by jatosStudyResultId
sorted_data <- last_trial_data[order(last_trial_data$jatosStudyResultId), ]
rownames(sorted_data) <- NULL
# Load Metadata
metadata1 <- read.csv("jatos_results_metadata_0907.csv")
metadata2 <- read.csv("jatos_results_metadata_0907_en.csv")
metadata <- rbind(metadata1, metadata2)
# Ensure colnames are the same
colnames(metadata)[colnames(metadata) == "Result.ID"] <- "jatosStudyResultId"
# Merge the two data.frames
exp_result <- merge(sorted_data, metadata[, c("jatosStudyResultId", "Start.time", "Duration")],
by = "jatosStudyResultId", all.x = TRUE)
# delete total responses
exp_result$total_responses <- NULL
# head(exp_result, n = 120)
nrow(exp_result)
exp_result
View(exp_result)
merged_data <- read.csv("merged_data_0907.csv")
# Merge cum_perseverative_error into merged_data
merged_data <- merged_data %>%
left_join(exp_result %>% select(jatosStudyResultId, cum_perseverative_error), by = "jatosStudyResultId")
View(merged_data)
write.csv(merged_data, file = paste0(path, "/merged_data_0907.csv"), row.names = FALSE)
hist(merged_data$cum_perserverative_error)
hist(merged_data$cum_perseverative_error)
summary(merged_data$cum_perseverative_error)
boxplot(merged_data$cum_perseverative_error)
order(merged_data$cum_perseverative_error)
sort(merged_data$cum_perseverative_error)
merged_data[merged_data$cum_perseverative_error == 0, ]
View(look)
look[look$cum_perseverative_error == 0, ]
head(look[look$cum_perseverative_error == 0, ], n = 100)
head(look[look$cum_perseverative_error == 0, ], n = 50)
head(look[look$cum_perseverative_error == 0, ], n = 10)
head(look[look$cum_perseverative_error == 0, ])
look2 <- look[look$cum_perseverative_error == 0, ]
look2
View(look2)
look2 <- look[look$cum_perseverative_error == 0 & look$total_responses == 64, ]
look2
look3 <- look2$jatosStudyResultId
look3
look[ , look$jatosStudyResultId %in% look3]
look[ , look3 %in% look$jatosStudyResultId]
look[look$jatosStudyResultId %in% look3, ]
look_filtered <-look[look$jatosStudyResultId %in% look3, ]
View(look_filtered)
# Calculate the IQR
Q1 <- quantile(merged_data$cum_perseverative_error, 0.25, na.rm = TRUE)
Q3 <- quantile(merged_data$cum_perseverative_error, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
# Determine the upper and lower bounds
lower_bound <- Q1 - 1.5 * IQR
upper_bound <- Q3 + 1.5 * IQR
# Filter merged_data based on the calculated bounds
merged_filtered <- merged_data[merged_data$cum_perseverative_error >= lower_bound & merged_data$cum_perseverative_error <= upper_bound, ]
boxplot(merged_filtered$cum_perseverative_error)
merged_filtered$cum_perseverative_error < 5
merged_filtered[merged_filtered$cum_perseverative_error < 5]
merged_filtered[ ,merged_filtered$cum_perseverative_error < 5]
merged_filtered[merged_filtered$cum_perseverative_error < 5, ]
which(merged_filtered$cum_perseverative_error < 5)
id <- which(merged_filtered$cum_perseverative_error < 5)
merged_filted[id, merged_filtered$jatosStudyResultId]
merged_filtered[id, merged_filtered$jatosStudyResultId]
merged_filtered[id, jatosStudyResultId]
View(look_filtered)
id <- which(merged_filtered$cum_perseverative_error < 5)
id
merged_filtered$jatosStudyResultId[id]
jatos <- merged_filtered$jatosStudyResultId[id]
merged_filtered[jatos, ]
merged_filtered[ ,jatos]
merged_filtered[merged_filtered$jatosStudyResultId == jatos, ]
bool <- merged_filtered$jatosStudyResultId == jatos
bool
merged_filtered[bool, ]
jatos <- merged_filtered$jatosStudyResultId[id]
jatos
bool <- merged_filtered$jatosStudyResultId == jatos
bool <- merged_filtered$jatosStudyResultId == jatos
bool <- merged_filtered$jatosStudyResultId %in% jatos
bool
merged_filtered[bool, ]
bool <- look$jatosStudyResultId %in% jatos
look[bool, ]
look4 <- look[bool, ]
View(look4)
library(ggplot2)
ggplot(merged_filtered, aes(x = MMM_S_Index, y = cum_perseverative_error)) +
geom_point()
hist(merged_filtered$cum_perseverative_error)
# Q-Q Plot
qqnorm(merged_filted$cum_perseverative_error, main = "Q-Q Plot of merged_filted$cum_perseverative_error")
# Q-Q Plot
qqnorm(merged_filtered$cum_perseverative_error, main = "Q-Q Plot of merged_filtered$cum_perseverative_error")
qqline(merged_filtered$cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test <- shapiro.test(merged_filtered$cum_perseverative_error)
print(shapiro_test)
# Kolmogorov-Smirnov Test
ks_test <- ks.test(merged_filtered$cum_perseverative_error, "pnorm", mean(merged_filtered$cum_perseverative_error), sd(merged_filtered$cum_perseverative_error))
print(ks_test)
# Anderson-Darling Test
ad_test <- ad.test(merged_filtered$cum_perseverative_error)
print(ad_test)
hist(merged_filtered$cum_perseverative_error)
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 20, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Q-Q plot with confidence interval
qqnorm(merged_filtered$cum_perseverative_error, main = "Q-Q Plot of cum_perseverative_error")
qqline(merged_filtered$cum_perseverative_error, col = "red")
print(ad_test)
print(ad_test)
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 20, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 30, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 25, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 25, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 22, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 24, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 23, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 22, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Q-Q plot with confidence interval
qqnorm(merged_filtered$cum_perseverative_error, main = "Q-Q Plot of cum_perseverative_error")
qqline(merged_filtered$cum_perseverative_error, col = "red")
# Re-plot Histogram with different bins
hist(merged_filtered$cum_perseverative_error, breaks = 22, main = "Histogram of cum_perseverative_error", xlab = "cum_perseverative_error")
# Apply log transformation
merged_filtered$log_cum_perseverative_error <- log(merged_filtered$cum_perseverative_error + 1)
# Plot histogram of the log-transformed data
hist(merged_filtered$log_cum_perseverative_error, breaks = 20, main = "Histogram of log-transformed cum_perseverative_error", xlab = "log(cum_perseverative_error)")
# Q-Q plot of the log-transformed data
qqnorm(merged_filtered$log_cum_perseverative_error, main = "Q-Q Plot of log-transformed cum_perseverative_error")
qqline(merged_filtered$log_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_log <- shapiro.test(merged_filtered$log_cum_perseverative_error)
print(shapiro_test_log)
# Reflect the data by subtracting from a constant greater than the max value
max_value <- max(merged_filtered$cum_perseverative_error, na.rm = TRUE)
reflected_data <- max_value - merged_filtered$cum_perseverative_error
# Apply log transformation to the reflected data
merged_filtered$log_reflected_cum_perseverative_error <- log(reflected_data + 1)  # Add 1 to avoid log(0)
# Plot histogram of the log-transformed reflected data
hist(merged_filtered$log_reflected_cum_perseverative_error, breaks = 20, main = "Histogram of log-transformed reflected cum_perseverative_error", xlab = "log(reflected cum_perseverative_error)")
# Q-Q plot of the log-transformed reflected data
qqnorm(merged_filtered$log_reflected_cum_perseverative_error, main = "Q-Q Plot of log-transformed reflected cum_perseverative_error")
qqline(merged_filtered$log_reflected_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_log_reflected <- shapiro.test(merged_filtered$log_reflected_cum_perseverative_error)
print(shapiro_test_log_reflected)
# Reflect the data by subtracting from a constant greater than the max value
max_value <- max(merged_filtered$cum_perseverative_error, na.rm = TRUE)
reflected_data <- max_value - merged_filtered$cum_perseverative_error
# Apply log transformation to the reflected data
merged_filtered$log_reflected_cum_perseverative_error <- log(reflected_data + 1)  # Add 1 to avoid log(0)
# Plot histogram of the log-transformed reflected data
hist(merged_filtered$log_reflected_cum_perseverative_error, breaks = 20, main = "Histogram of log-transformed reflected cum_perseverative_error", xlab = "log(reflected cum_perseverative_error)")
# Q-Q plot of the log-transformed reflected data
qqnorm(merged_filtered$log_reflected_cum_perseverative_error, main = "Q-Q Plot of log-transformed reflected cum_perseverative_error")
qqline(merged_filtered$log_reflected_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_log_reflected <- shapiro.test(merged_filtered$log_reflected_cum_perseverative_error)
print(shapiro_test_log_reflected)
# Reflect the data by subtracting from a constant greater than the max value
max_value <- max(merged_filtered$cum_perseverative_error, na.rm = TRUE)
reflected_data <- max_value - merged_filtered$cum_perseverative_error
# Apply square root transformation to the reflected data
merged_filtered$sqrt_reflected_cum_perseverative_error <- sqrt(reflected_data)
# Plot histogram of the square root-transformed reflected data
hist(merged_filtered$sqrt_reflected_cum_perseverative_error, breaks = 20, main = "Histogram of square root-transformed reflected cum_perseverative_error", xlab = "sqrt(reflected cum_perseverative_error)")
# Q-Q plot of the square root-transformed reflected data
qqnorm(merged_filtered$sqrt_reflected_cum_perseverative_error, main = "Q-Q Plot of square root-transformed reflected cum_perseverative_error")
qqline(merged_filtered$sqrt_reflected_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_sqrt_reflected <- shapiro.test(merged_filtered$sqrt_reflected_cum_perseverative_error)
print(shapiro_test_sqrt_reflected)
# Plot histogram of the square root-transformed reflected data
hist(merged_filtered$sqrt_reflected_cum_perseverative_error, breaks = 20, main = "Histogram of square root-transformed reflected cum_perseverative_error", xlab = "sqrt(reflected cum_perseverative_error)")
# Q-Q plot of the square root-transformed reflected data
qqnorm(merged_filtered$sqrt_reflected_cum_perseverative_error, main = "Q-Q Plot of square root-transformed reflected cum_perseverative_error")
qqline(merged_filtered$sqrt_reflected_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_sqrt_reflected <- shapiro.test(merged_filtered$sqrt_reflected_cum_perseverative_error)
print(shapiro_test_sqrt_reflected)
library(MASS)
# Reflect the data by subtracting from a constant greater than the max value
max_value <- max(merged_filtered$cum_perseverative_error, na.rm = TRUE)
reflected_data <- max_value - merged_filtered$cum_perseverative_error
# Apply Box-Cox transformation
bc <- boxcox(reflected_data ~ 1, lambda = seq(-2, 2, 0.1))
library(MASS)
# Reflect the data by subtracting from a constant larger than the max value and adding a small constant
max_value <- max(merged_filtered$cum_perseverative_error, na.rm = TRUE)
small_constant <- 1  # Small constant to ensure all values are positive
reflected_data <- (max_value + small_constant) - merged_filtered$cum_perseverative_error
# Apply Box-Cox transformation
bc <- boxcox(reflected_data ~ 1, lambda = seq(-2, 2, 0.1))
best_lambda <- bc$x[which.max(bc$y)]
merged_filtered$boxcox_reflected_cum_perseverative_error <- (reflected_data^best_lambda - 1) / best_lambda
# Plot histogram of the Box-Cox transformed data
hist(merged_filtered$boxcox_reflected_cum_perseverative_error, breaks = 20, main = "Histogram of Box-Cox transformed reflected cum_perseverative_error", xlab = "Box-Cox(reflected cum_perseverative_error)")
# Q-Q plot of the Box-Cox transformed data
qqnorm(merged_filtered$boxcox_reflected_cum_perseverative_error, main = "Q-Q Plot of Box-Cox transformed reflected cum_perseverative_error")
qqline(merged_filtered$boxcox_reflected_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_boxcox_reflected <- shapiro.test(merged_filtered$boxcox_reflected_cum_perseverative_error)
print(shapiro_test_boxcox_reflected)
# Plot histogram of the Box-Cox transformed data
hist(merged_filtered$boxcox_reflected_cum_perseverative_error, breaks = 20, main = "Histogram of Box-Cox transformed reflected cum_perseverative_error", xlab = "Box-Cox(reflected cum_perseverative_error)")
# Q-Q plot of the Box-Cox transformed data
qqnorm(merged_filtered$boxcox_reflected_cum_perseverative_error, main = "Q-Q Plot of Box-Cox transformed reflected cum_perseverative_error")
qqline(merged_filtered$boxcox_reflected_cum_perseverative_error, col = "red")
# Shapiro-Wilk Test
shapiro_test_boxcox_reflected <- shapiro.test(merged_filtered$boxcox_reflected_cum_perseverative_error)
print(shapiro_test_boxcox_reflected)
# Fit the linear model
# Replace predictor1 and predictor2 with the actual column names you want to use as predictors
model <- lm(boxcox_reflected_cum_perseverative_error ~ MMM_S_Index, data = merged_filtered)
# Check the model summary
summary(model)
model2 <- lm(boxcox_reflected_cum_perseverative_error ~ poly(MMM_S_Index, 2), data = merged_filtered))
model2 <- lm(boxcox_reflected_cum_perseverative_error ~ poly(MMM_S_Index, 2), data = merged_filtered)
# Check the model summary
summary(model)
summary(model2)
par(mfrow(c(2, 2))
)
plot(model)
par(mfrow(c(2, 2)))
par(mfrow = c(2, 2))
plot(model)
plot(model2)
plot(model)
plot(model2)
plot(model)
hist(reflected_data)
# Assuming merged_data is your data frame
merged_data$p_error <- (merged_data$cum_perseverative_error / 64) * 100
# Merge cum_perseverative_error into merged_data
merged_data <- merged_data %>%
left_join(exp_result %>% select(jatosStudyResultId, cum_perseverative_error), by = "jatosStudyResultId")
library(dplyr)
# Add a column to count the cumulative number of perseverative errors for each participant
look <- look %>%
group_by(jatosStudyResultId) %>%  # Use 'jatosStudyResultId' to group by participant
mutate(
cum_perseverative_error = cumsum(perseverative_error)
) %>%
ungroup()
